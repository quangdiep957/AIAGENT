import streamlit as st
import uuid
import os
import asyncio
import time
from datetime import datetime

# Import c√°c tools ƒë√£ t·∫°o
from tools import FileUploadTool, FileReaderTool, OCRTool, EmbeddingTool, VectorSearchTool
from services import EmbeddingService
from models import DocumentModel, DocumentUtils
from database import DatabaseManager
from agents import create_agent

st.set_page_config(page_title="AI Tutor", page_icon="ü§ñ", layout="wide")

UPLOAD_DIR = "uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)

# Kh·ªüi t·∫°o c√°c tools
@st.cache_resource
def init_tools():
    """Kh·ªüi t·∫°o c√°c tools cho document processing"""
    try:
        upload_tool = FileUploadTool(upload_dir=UPLOAD_DIR)
        reader_tool = FileReaderTool()
        ocr_tool = OCRTool()
        embedding_tool = EmbeddingTool()
        search_tool = VectorSearchTool()
        embedding_service = EmbeddingService()
        db_manager = DatabaseManager()
        ai_agent = create_agent()
        
        return {
            "upload_tool": upload_tool,
            "reader_tool": reader_tool,
            "ocr_tool": ocr_tool,
            "embedding_tool": embedding_tool,
            "search_tool": search_tool,
            "embedding_service": embedding_service,
            "db_manager": db_manager,
            "ai_agent": ai_agent,
            "status": "success"
        }
    except Exception as e:
        return {
            "status": "error",
            "error": str(e)
        }

# Kh·ªüi t·∫°o tools
tools = init_tools()

# --- Custom Dark CSS ---
st.markdown("""
<style>
/* To√†n b·ªô n·ªÅn */
.stApp {
    background-color: #1e1e2e;
    color: #e5e5e5;
    font-family: 'Segoe UI', sans-serif;
}

/* Header */
.header {
    text-align: center;
    padding: 20px 0;
    font-size: 26px;
    font-weight: bold;
    color: #60a5fa;
}

/* Chat container */
.chat-bubble {
    padding: 12px 18px;
    margin: 8px 0;
    border-radius: 18px;
    max-width: 80%;
    line-height: 1.5;
    word-wrap: break-word;
    box-shadow: 0px 2px 6px rgba(0,0,0,0.2);
}
.chat-user {
    background-color: #3b82f6;
    color: white;
    margin-left: auto;
}
.chat-ai {
    background-color: #2e2e3e;
    color: #f3f4f6;
    margin-right: auto;
}

/* Input bar c·ªë ƒë·ªãnh cu·ªëi */
.input-container {
    position: fixed;
    bottom: 0;
    left: 18%;
    width: 82%;
    background: #2a2a3a;
    border-top: 1px solid #3f3f46;
    padding: 10px 15px;
    border-radius: 12px 12px 0 0;
}
</style>
""", unsafe_allow_html=True)

# --- State ---
if "sessions" not in st.session_state:
    st.session_state.sessions = {}  
if "current_session" not in st.session_state:
    sid = str(uuid.uuid4())
    st.session_state.sessions[sid] = {"name": None, "messages": []}
    st.session_state.current_session = sid
if "show_uploader" not in st.session_state:
    st.session_state.show_uploader = False
if "processing_files" not in st.session_state:
    st.session_state.processing_files = {}
if "uploaded_documents" not in st.session_state:
    st.session_state.uploaded_documents = []


def process_uploaded_file(uploaded_file, session_id):
    """X·ª≠ l√Ω file ƒë√£ upload"""
    try:
        if tools["status"] != "success":
            return {
                "success": False,
                "error": "Tools ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch"
            }
        
        # L∆∞u file t·∫°m
        temp_file_path = os.path.join(UPLOAD_DIR, f"temp_{uuid.uuid4().hex}_{uploaded_file.name}")
        with open(temp_file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        
        # Upload s·ª≠ d·ª•ng FileUploadTool
        upload_result = tools["upload_tool"].upload_file(
            file_path=temp_file_path,
            metadata={
                "session_id": session_id,
                "original_name": uploaded_file.name,
                "upload_source": "streamlit_ui"
            }
        )
        
        if not upload_result["success"]:
            return {
                "success": False,
                "error": f"Upload failed: {', '.join(upload_result['errors'])}"
            }
        
        file_document = upload_result["document"]
        file_id = upload_result["file_id"]
        
        # Extract content d·ª±a tr√™n lo·∫°i file
        content = ""
        extraction_method = ""
        
        file_type = file_document["file_type"]
        file_path = file_document["absolute_path"]
        
        if file_type in ["pdf", "docx", "doc", "txt", "md"]:
            # ƒê·ªçc file text-based
            read_result = tools["reader_tool"].read_file(file_path)
            if read_result["success"]:
                if file_type == "pdf":
                    content = read_result["total_content"]
                elif file_type in ["docx", "doc"]:
                    content = read_result["total_content"]
                else:  # text files
                    content = read_result["content"]
                extraction_method = "file_reader"
            else:
                return {
                    "success": False,
                    "error": f"Kh√¥ng th·ªÉ ƒë·ªçc file: {read_result['error']}"
                }
        
        elif file_type == "image":
            # OCR cho ·∫£nh
            print(f"üîç Starting OCR for image: {file_path}")
            ocr_result = tools["ocr_tool"].extract_text_from_image(file_path)
            print(f"üìä OCR result: {ocr_result}")
            
            if ocr_result["success"]:
                content = ocr_result["text"]
                extraction_method = "ocr"
                print(f"‚úÖ OCR successful. Text length: {len(content)} characters")
            else:
                print(f"‚ùå OCR failed: {ocr_result['error']}")
                return {
                    "success": False,
                    "error": f"OCR failed: {ocr_result['error']}"
                }
        
        if not content or not content.strip():
            print(f"‚ö†Ô∏è Warning: No content extracted. Content length: {len(content) if content else 0}")
            return {
                "success": False,
                "error": "Kh√¥ng th·ªÉ tr√≠ch xu·∫•t n·ªôi dung t·ª´ file. File c√≥ th·ªÉ r·ªóng ho·∫∑c kh√¥ng ch·ª©a text c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c."
            }
        
        # T·∫°o embeddings
        processing_result = tools["embedding_service"].process_file_content(
            file_id=file_id,
            content=content,
            metadata={
                "session_id": session_id,
                "extraction_method": extraction_method,
                "file_type": file_type
            }
        )
        
        if not processing_result["success"]:
            return {
                "success": False,
                "error": f"Embedding processing failed: {processing_result['error']}"
            }
        
        # Cleanup temp file
        if os.path.exists(temp_file_path):
            os.remove(temp_file_path)
        
        return {
            "success": True,
            "file_id": file_id,
            "file_info": {
                "filename": file_document["filename"],
                "file_type": file_type,
                "file_size": file_document["file_size"]
            },
            "content_info": {
                "length": len(content),
                "word_count": len(content.split()),
                "content_type": processing_result["content_type"],
                "topic": processing_result["topic"],
                "difficulty": processing_result["difficulty_level"],
                "tags": processing_result["tags"]
            },
            "processing_info": {
                "total_chunks": processing_result["total_chunks"],
                "total_tokens": processing_result["total_tokens"],
                "extraction_method": extraction_method
            }
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": f"L·ªói x·ª≠ l√Ω file: {str(e)}"
        }


def search_relevant_content(query, limit=3):
    """T√¨m ki·∫øm n·ªôi dung li√™n quan t·ª´ database"""
    try:
        if tools["status"] != "success":
            return []
        
        search_result = tools["search_tool"].similarity_search(
            query_text=query,
            limit=limit,
            similarity_threshold=0.3
        )
        
        if search_result["success"] and search_result["results"]:
            relevant_docs = []
            for doc in search_result["results"]:
                relevant_docs.append({
                    "content": doc["content"][:300] + "..." if len(doc["content"]) > 300 else doc["content"],
                    "similarity": doc["similarity_score"],
                    "type": doc.get("type", "unknown"),
                    "topic": doc.get("topic", "N/A")
                })
            return relevant_docs
        
        return []
        
    except Exception as e:
        print(f"Search error: {e}")
        return []


def generate_ai_response(user_message, relevant_docs=None):
    """T·∫°o ph·∫£n h·ªìi AI s·ª≠ d·ª•ng agent v·ªõi context t·ª´ documents"""
    try:
        if tools["status"] != "success":
            return "‚ùå AI Agent ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch"
        
        # Chu·∫©n b·ªã context cho agent
        context_info = ""
        if relevant_docs:
            context_info = f"\n\nTh√¥ng tin li√™n quan t·ª´ t√†i li·ªáu:\n"
            for i, doc in enumerate(relevant_docs, 1):
                context_info += f"üìÑ T√†i li·ªáu {i}: {doc['content'][:200]}...\n"
        
        # T·∫°o prompt cho agent
        agent_prompt = f"""
B·∫°n l√† AI Tutor, m·ªôt tr·ª£ l√Ω h·ªçc t·∫≠p ti·∫øng Anh th√¥ng minh v√† th√¢n thi·ªán. H√£y tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa h·ªçc sinh m·ªôt c√°ch chi ti·∫øt v√† h·ªØu √≠ch.

C√¢u h·ªèi c·ªßa h·ªçc sinh: {user_message}
{context_info}

QUY T·∫ÆC QUAN TR·ªåNG:
1. Giao ti·∫øp v√† gi·∫£i th√≠ch b·∫±ng TI·∫æNG VI·ªÜT
2. N·ªôi dung ti·∫øng Anh (truy·ªán, v√≠ d·ª•, c√¢u m·∫´u) PH·∫¢I GI·ªÆ NGUY√äN TI·∫æNG ANH - KH√îNG D·ªäCH
3. Ch·ªâ gi·∫£i th√≠ch nghƒ©a ho·∫∑c th√™m ch√∫ th√≠ch b·∫±ng ti·∫øng Vi·ªát n·∫øu c·∫ßn

H∆∞·ªõng d·∫´n tr·∫£ l·ªùi:
1. N·∫øu c√¢u h·ªèi li√™n quan ƒë·∫øn vi·ªác t√¨m ki·∫øm th√¥ng tin t·ª´ t√†i li·ªáu ƒë√£ upload, h√£y s·ª≠ d·ª•ng tool search_documents
2. N·∫øu h·ªçc sinh mu·ªën bi·∫øt th·ªëng k√™ t√†i li·ªáu, h√£y s·ª≠ d·ª•ng tool get_document_summary  
3. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, th√¢n thi·ªán v√† d·ªÖ hi·ªÉu
4. S·ª≠ d·ª•ng emoji ƒë·ªÉ l√†m cho c√¢u tr·∫£ l·ªùi sinh ƒë·ªông
5. C·∫•u tr√∫c r√µ r√†ng v·ªõi c√°c ƒëi·ªÉm ch√≠nh
6. GI·ªÆ NGUY√äN t·∫•t c·∫£ n·ªôi dung ti·∫øng Anh t·ª´ t√†i li·ªáu (truy·ªán, c√¢u v√≠ d·ª•, b√†i t·∫≠p)
7. C√≥ th·ªÉ th√™m ch√∫ th√≠ch nghƒ©a ti·∫øng Vi·ªát trong ngo·∫∑c ƒë∆°n n·∫øu c·∫ßn
8. N·∫øu kh√¥ng t√¨m th·∫•y th√¥ng tin li√™n quan, g·ª£i √Ω h·ªçc sinh upload th√™m t√†i li·ªáu

V√≠ d·ª• format mong mu·ªën:
- Gi·∫£i th√≠ch: "ƒê√¢y l√† truy·ªán ng·∫Øn ƒë∆°n gi·∫£n ƒë·ªÉ luy·ªán ƒë·ªçc:"
- N·ªôi dung ti·∫øng Anh: "She goes to the zoo. She sees a lion."
- Ch√∫ th√≠ch n·∫øu c·∫ßn: "(C√¥ ·∫•y ƒëi s·ªü th√∫. C√¥ ·∫•y nh√¨n th·∫•y m·ªôt con s∆∞ t·ª≠.)"

H√£y tr·∫£ l·ªùi m·ªôt c√°ch t·ª± nhi√™n v√† h·ªØu √≠ch:
"""
        
        # G·ªçi AI agent
        response = tools["ai_agent"].invoke({"input": agent_prompt})
        
        # Extract response t·ª´ agent output
        if isinstance(response, dict) and "output" in response:
            agent_response = response["output"]
        else:
            agent_response = str(response)
        
        # Clean up JSON response n·∫øu c√≥
        if "action_input" in agent_response:
            try:
                import json
                # Try to extract action_input from JSON
                lines = agent_response.strip().split('\n')
                for line in lines:
                    if '"action_input"' in line:
                        # Extract the value after action_input
                        start = line.find('"action_input": "') + len('"action_input": "')
                        end = line.rfind('"')
                        if start < end:
                            agent_response = line[start:end]
                            break
            except:
                pass
        
        # Clean up escape characters v√† format markdown
        agent_response = agent_response.replace('\\n', '\n')  # Fix newlines
        agent_response = agent_response.replace('\\"', '"')   # Fix quotes
        agent_response = agent_response.replace('\\/', '/')   # Fix slashes
        
        # ƒê·∫£m b·∫£o response c√≥ format ƒë·∫πp
        if not agent_response.startswith('ü§ñ') and not agent_response.startswith('üìö'):
            agent_response = f"ü§ñ **AI Tutor:**\n\n{agent_response}"
        
        return agent_response
        
    except Exception as e:
        # Fallback v·ªÅ response c≈© n·∫øu agent b·ªã l·ªói
        if relevant_docs:
            context = "\n\n".join([f"üìÑ {doc['type']}: {doc['content']}" for doc in relevant_docs])
            response = f"""
üìö **D·ª±a tr√™n t√†i li·ªáu ƒë√£ upload, t√¥i t√¨m th·∫•y th√¥ng tin li√™n quan:**

{context}

---

üí° **Tr·∫£ l·ªùi cho c√¢u h·ªèi c·ªßa b·∫°n:**
{user_message}

D·ª±a tr√™n n·ªôi dung tr√™n, ƒë√¢y l√† g·ª£i √Ω h·ªçc t·∫≠p ph√π h·ª£p v·ªõi c√¢u h·ªèi c·ªßa b·∫°n.

‚ö†Ô∏è *L∆∞u √Ω: AI Agent ƒëang g·∫∑p v·∫•n ƒë·ªÅ ({str(e)}), ƒë√¢y l√† ph·∫£n h·ªìi d·ª± ph√≤ng*
            """
        else:
            response = f"""
ü§ñ **AI Tutor ph·∫£n h·ªìi:**

T√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c c√¢u h·ªèi: "{user_message}"

Hi·ªán t·∫°i ch∆∞a c√≥ t√†i li·ªáu n√†o ƒë∆∞·ª£c upload ƒë·ªÉ tham kh·∫£o. B·∫°n c√≥ th·ªÉ:
- Upload t√†i li·ªáu h·ªçc t·∫≠p (PDF, Word, h√¨nh ·∫£nh)
- ƒê·∫∑t c√¢u h·ªèi c·ª• th·ªÉ v·ªÅ ch·ªß ƒë·ªÅ b·∫°n quan t√¢m

T√¥i s·∫Ω gi√∫p b·∫°n h·ªçc t·∫≠p hi·ªáu qu·∫£ h∆°n! üìò

‚ö†Ô∏è *L∆∞u √Ω: AI Agent ƒëang g·∫∑p v·∫•n ƒë·ªÅ ({str(e)}), ƒë√¢y l√† ph·∫£n h·ªìi d·ª± ph√≤ng*
            """
        
        return response


def new_session():
    # ch·ªâ t·∫°o m·ªõi n·∫øu phi√™n hi·ªán t·∫°i ƒë√£ c√≥ n·ªôi dung
    current = st.session_state.sessions.get(st.session_state.current_session, None)
    if current and not current["messages"]:
        st.toast("üìå H√£y nh·∫≠p c√¢u h·ªèi tr∆∞·ªõc khi t·∫°o phi√™n m·ªõi")
        return  
    sid = str(uuid.uuid4())
    st.session_state.sessions[sid] = {"name": None, "messages": []}
    st.session_state.current_session = sid


def delete_session(sid):
    if sid in st.session_state.sessions:
        del st.session_state.sessions[sid]
        if not st.session_state.sessions:
            new_session()
        else:
            st.session_state.current_session = list(st.session_state.sessions.keys())[0]


def shorten_name(text, max_len=18):
    return text if len(text) <= max_len else text[:max_len] + "..."


# --- Sidebar ---
st.sidebar.header("üìö AI Tutor")
st.sidebar.button("‚ûï B·∫Øt ƒë·∫ßu phi√™n m·ªõi", on_click=new_session)

st.sidebar.subheader("üìú L·ªãch s·ª≠ h·ªçc t·∫≠p")
for sid, sess in list(st.session_state.sessions.items()):
    if sid == st.session_state.current_session and sess["name"] is None:
        continue  
    col1, col2 = st.sidebar.columns([4, 1])
    display_name = sess["name"] or "Ch∆∞a ƒë·∫∑t t√™n"
    display_name = shorten_name(display_name)
    if col1.button(display_name, key=f"open-{sid}"):
        st.session_state.current_session = sid
    if col2.button("‚ùå", key=f"del-{sid}"):
        delete_session(sid)
        st.rerun()


# --- Main layout ---
st.markdown("<div class='header'>ü§ñ AI Tutor ‚Äì Ng∆∞·ªùi b·∫°n ƒë·ªìng h√†nh h·ªçc t·∫≠p</div>", unsafe_allow_html=True)

chat_container = st.container()
input_container = st.container()

current = st.session_state.sessions[st.session_state.current_session]

with chat_container:
    if not current["messages"]:
        st.markdown(
            "<div style='text-align:center; font-size:18px; color:gray; margin-top:100px;'>"
            "Xin ch√†o üëã, t√¥i l√† <b>AI Tutor</b>.<br/>"
            "B·∫°n mu·ªën h·ªçc g√¨ h√¥m nay? üìò"
            "</div>",
            unsafe_allow_html=True,
        )
    else:
        for m in current["messages"]:
            role_class = "chat-user" if m["role"] == "user" else "chat-ai"
            st.markdown(f"<div class='chat-bubble {role_class}'>{m['content']}</div>", unsafe_allow_html=True)


with input_container:
    st.markdown("<div class='input-container'>", unsafe_allow_html=True)
    cols = st.columns([0.1, 0.9])
    with cols[0]:
        if st.button("üìé", key="icon-upload"):
            st.session_state.show_uploader = not st.session_state.show_uploader
        if st.session_state.show_uploader:
            st.markdown("### üì§ Upload File")
            uploaded_files = st.file_uploader(
                "Ch·ªçn file ƒë·ªÉ upload:", 
                type=['pdf', 'docx', 'doc', 'txt', 'md', 'png', 'jpg', 'jpeg'],
                accept_multiple_files=True,
                key="main_uploader"
            )
            
            if uploaded_files:
                for uploaded_file in uploaded_files:
                    file_key = f"{uploaded_file.name}_{uploaded_file.size}"
                    
                    # Check if file is already being processed
                    if file_key not in st.session_state.processing_files:
                        st.session_state.processing_files[file_key] = "processing"
                        
                        # Show processing indicator
                        with st.spinner(f"ƒêang x·ª≠ l√Ω file: {uploaded_file.name}..."):
                            result = process_uploaded_file(uploaded_file, st.session_state.current_session)
                            
                            if result["success"]:
                                st.session_state.processing_files[file_key] = "completed"
                                st.session_state.uploaded_documents.append(result)
                                
                                # Add file message to chat
                                current["messages"].append({
                                    "role": "user", 
                                    "type": "file", 
                                    "content": f"üìÑ ƒê√£ upload: {uploaded_file.name} ({result['file_info']['file_type']})\n"
                                              f"üìä Ch·ªß ƒë·ªÅ: {result['content_info']['topic']}\n"
                                              f"üìè {result['content_info']['word_count']:,} t·ª´"
                                })
                                
                                # AI response about the uploaded file
                                ai_response = f"""
üìö **ƒê√£ nh·∫≠n v√† x·ª≠ l√Ω file: {uploaded_file.name}**

‚úÖ **Th√¥ng tin file:**
- Lo·∫°i: {result['file_info']['file_type'].upper()}
- K√≠ch th∆∞·ªõc: {result['file_info']['file_size']:,} bytes
- N·ªôi dung: {result['content_info']['word_count']:,} t·ª´

üîç **Ph√¢n t√≠ch n·ªôi dung:**
- Ch·ªß ƒë·ªÅ: {result['content_info']['topic']}
- ƒê·ªô kh√≥: {result['content_info']['difficulty']}
- Tags: {', '.join(result['content_info']['tags'])}

üí° T√¥i ƒë√£ t·∫°o embedding cho {result['processing_info']['total_chunks']} ph·∫ßn n·ªôi dung. 
B√¢y gi·ªù b·∫°n c√≥ th·ªÉ ƒë·∫∑t c√¢u h·ªèi v·ªÅ n·ªôi dung trong file n√†y!
                                """
                                current["messages"].append({
                                    "role": "assistant", 
                                    "type": "text", 
                                    "content": ai_response
                                })
                                
                                # Update session name if needed
                                if current["name"] is None:
                                    current["name"] = uploaded_file.name
                                
                                st.success(f"‚úÖ ƒê√£ x·ª≠ l√Ω: {uploaded_file.name}")
                                
                            else:
                                st.session_state.processing_files[file_key] = "error"
                                st.error(f"‚ùå L·ªói: {result['error']}")
                                
                                # Add error message to chat
                                current["messages"].append({
                                    "role": "assistant", 
                                    "type": "text", 
                                    "content": f"‚ùå **L·ªói x·ª≠ l√Ω file: {uploaded_file.name}**\n\n{result['error']}"
                                })
            
            # Show uploaded documents summary
            if st.session_state.uploaded_documents:
                st.markdown("### üìö T√†i li·ªáu ƒë√£ upload")
                for doc in st.session_state.uploaded_documents:
                    st.write(f"üìÑ {doc['file_info']['filename']} - {doc['content_info']['topic']}")
            
            col1, col2 = st.columns([1, 1])
            with col1:
                if st.button("‚úÖ Ho√†n th√†nh", key="finish_upload"):
                    st.session_state.show_uploader = False
                    st.rerun()
            with col2:
                if st.button("‚ùå ƒê√≥ng", key="close_upload"):
                    st.session_state.show_uploader = False
                    st.rerun()

    with cols[1]:
        prompt = st.chat_input("‚úçÔ∏è Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n...")
        if prompt:
            # add user message
            current["messages"].append({"role": "user", "type": "text", "content": prompt})
            if current["name"] is None:
                current["name"] = prompt

            # Search for relevant content from uploaded documents
            relevant_docs = search_relevant_content(prompt, limit=3)
            
            # Generate AI response with context
            ai_response = generate_ai_response(prompt, relevant_docs)
            current["messages"].append({"role": "assistant", "type": "text", "content": ai_response})
            st.rerun()
    st.markdown("</div>", unsafe_allow_html=True)
